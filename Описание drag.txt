Метки:
1) main - главный цикл, который ждёт прерываний
2) exit_isr - функция выхода из обработчика прерывания
3) place - основная функция программы
4) getstart - функция, которая по номеру колоды найдёт адрес последней закрытой в этой колоде карты
5) deck - адрес, где лежат все карты. Прямо сейчас в программе заполнена примером колоды
6) deck_offset - массив, где содержатся адреса начал колод
7) from_to - адрес одного байта, в котором хранится информация из какой и в какую колоду нужно перенести карты: 4 старшие бита - отткуда, 4 младшие - куда
8) count_win - адрес одного байта, в котором хранится количество сброшенных колод

Описание программы (все строчки указаны на момент 12.05.2022, в версии isr):
	0)Строчка 2 - сдвинуть stack pointer с памяти, предназначенной для устройств ввода вывода
	  Строчка 3 - включить прерывания
	I)main: ждёт пока вызовут софт, потом выполняет его (это происходит за кадром) и повторяет саму себя - br main.
	II)exit_isr: очищает стек: stsp записывает значение в stack pointer. Потом выходим из обработки прерывания - rti
	III)place:
		Строчки 17-21: Найдем первую открытую карту колоды, куда будем складывать. В r2 получаем номер карты, куда будем перемещать, для этого получаем из from_to только младшие биты маской - and r0, r2. После И с маской старшие биты ничего не значат (равны 0). С помощью функции getstart, сохраняем адрес первой открытой карты в колоды под номером, который мы получили, в регистр r3
		Строчки 26-32: Ищем ячейку, куда можно сложить карты: либо первая пустая, либо начало следующей колоды (такой случай отловится позже). Продвигаясь по колоде с помощью инкрементирования r3 (там адрес карт лежит), загружая значение карт в r1 - ld r3, r1, получая "is_end" бит - and r0, r1, сравниваем его с 0. Когда найдём не ноль - найдем пустую карту или начало колоды, то есть место, куда можно перетащить карты. 
		Строчки 33-35: Сохраняем в стеке, найденный адрес - push r3. Смещаемся на 1 карту назад - получается та карта, на которую будем класть - сейчас лежит в r1 - ld r3, r1
		Строчки 38-44: Найдём первую открытую карту колоды, откуда будем перекладывать. В r2 как и в начале сохраняем номер колоды - ld r2, r2, но теперь он хранится в старших битах. Применяем 4 сдвига вправо - shra r2, чтобы старшие биты стали младшими. Т.е. например есть число 21, нужно добыть его старшую цифру, для этого можно сдвинуть все цифры вправо, то что останется будет результатом. Только в нашем случае нужно получить 4 последние цифры в 8-значном числе. Далее в r3 с помощью функции getstart сохраняем первую открытую карту, откуда будем брать
		Строчки 45-47: в r1 хранится карта, на которую будем перемещать колоду. Теперь с помощью маски в r0, получаем значение этой карты - and r0, r1. Уменьшая значение на 1, получаем то значение, которое должно на эту карту лечь (9 - 1 = 8, а как раз только 8 можно положить на 9)
		Строчки 48-53: Проверка на конец колоды. Если r1 = 1, то есть последняя карта это 2, то ничего на неё положить нельзя. Чтобы проверить, что r1 не 1, сравним r1 - 1 с нулём. Если не ноль, вернём r1 нормальное значение - вот и отловили случай из строчек 23-29
		Строчки 56-67: Ищем карту, которую можно положить. Сначала загружаем значение текущей карты из колоды, откуда перетаскиваем, в r2 (r3 хранит адрес первой открытой карты в этой колоде) - ld r3, r2. В r0 хранится маска для получения значения карты, применяем её к r2 - and r0, r2. Если её значение нулевое, то мы дошли до конца колоды, не найдя нужную карту, значит перетаскивание невозможно. Если значение ненулевое сравниваем его с предполагаемым в r1 (см пред раздел) - cmp r1, r2. Продолжаем искать, если они неравны, инкрементируем r3, чтобы получить адрес следующей карты
		*ОСОБЫЙ МОМЕНТ: можем ли поиском достичь конца одной колоды и переключиться на следующую?
		- Нет. Колода может "соприкасаться" в памяти с другой (последняя карта и начало колоды - соседние ячейки), только если все 9 карт в одной колоде собраны и открыты. Это верно, ведь максимальные размеры каждой колоды рассчитаны с учётом именно на то, что более чем 8 карт прибавить ни к какой колоде нельзя. Если мы прибавляем все 8, то мы обязаны сделать это вручную, то есть используя только открытые карты. Из всего этого следует вывод, что либо колода неполная и пустую ячейку мы найдем, либо колода и полная и любую подходящую карту мы найти сможем (хотя это будет глупый ход).
		Строчки 72-77: Открываем предыдущую карту. r0 - маска, открывающая карту (зануляет бит, отвечающий за открытость). В r3 хранится адрес карты, откуда переносим, уменьшая его, получаем адрес карты, на которой она лежит. Загружаем это значение в r2, открываем её (даже если уже открыта) И-кая её с r0, загружаем значение карты обратно по адресу - st r3, r2. Возвращаем r3 на перетаскиваемую карту - inc r3
		Строчки 79-91: Переносим карты. Из стека в r1 заносим адрес, куда будем складывать - pop r1, а в r0 - маску, которая скажет, когда остановить копирование. Загружаем значение карты, которую хотим перенести в r2, И-каем её с r0: если результат = 0, то либо уже конец колоды, либо начало следующей, иначе - просто карта. Снова загружаем карту в r2, сохраняем её по адресу, куда складываем - st r1, r2. Загружаем в r2 0 - ldi r2, 0, заносим его в ячейку, откуда взяли последнюю карту -> теперь ячейка пуста - st r3, r2. Дальше переходим на следующую карту (r3) и следующую свободную ячейку (r1)
		Строчки 93-102: Определим, собралась ли полная колода. Сначала достаём из стека адрес начала колонны, куда клали карты и кладём его обратно для того, чтобы потом начиная с этого адреса, удалить карты, которые в полную колоду входят. В r0 загружаем значение еквивалентное открытой девятки, и в цикле сравниваем его со значением расположенным по адерсу r3. На каждой итерации цикла уменьшаем ожидаемое значение (сначала должна идти 9, потом 8 и т.д.), если оно не равно текущей карте, то выходим из цикла. 
		Строчки 103-108. После цикла в r1 загружаем значение "открытой единицы": если полная колода есть, то в цикле проверка на двойку выполнена, то есть r0 уменьшилась на 1 и стала равна 1 и следующая проверка была провальной (никакая карта не равна открытой единице). Если r0 не равен r1, то выход из цикла случился раньше, т.е. полной колоды не нашлось.
		Строчки 109-114: Открываем карту, на которой лежит 9-ка, с которой начинается полная колода
		Строчки 115-123: Пробегаемся по полной колоде, смотря на "is_end" бит. Если карта - это не конец колоды, то зануляем её.
		Строчки 124-128: Загружаем адрес где лежит кол-во собранных колод. Инкрементируем это число и загружаем обратно по адресу, затем выходим из функции
		P.S. За предел колоды, куда складываем не выйдем, так как максимальные размеры подсчитаны для этого. Так же перемещения карт из колоды в неё саму не стоит бояться, так как все открытые карты уже лежат по убыванию и команда ничего перетащить не сможет 
			  
		P.S.S Завершение функции в любом месте делается исполнение функции выхода - exit_isr
	IV)getstart:
		Строчки 136-139: Получим адрес начала колоды. в r2 хранится непосредственно номер колоды, значит (r2 - 1) - индекс колоды в массиве колод. add r2, r3 - идёт обращение к r2-ому элементу массива. deck_offset хранит именно адреса начал колод, поэтому получаем хранящийся по адресу r3 адрес - ld r3, r3.
		Строчки 141-147: Найдем первую открытую карту. r0 - маска, если с ней и картой сделать операцию "И", то получим бит, который означает закрытость карты (см. card-bits). r3 содержит адрес карт колоды, инкрементирую его, проходимся по всем картам, загружаем их значение в r2, получаем бит закрытости карты. Если значение в r2 - не ноль, то карта закрыта. После цикла получим адрес первой открытой карты.
		Строчка 109: выход из функции
		P.S. Если карт вообще нет, то будет сохранена первая пустая ячейка.

Строчка 151: Записываем в 0xf0 адрес функции обработки прерывания

